#+REVEAL_ROOT: https://cdn.jsdelivr.net/reveal.js/2.6.2/
#+AUTHOR: Daniel Szmulewicz & Daniel Slutsky
#+EMAIL: 
#+REVEAL_THEME: moon
#+OPTIONS: num:nil toc:nil
#+Title: Let's talk about Clojure

* Part I: Introduction
** A little quiz for starters
Moshe is looking at Yael, and Yael is looking at Eli. Moshe is married, but Eli is not. Is a married person looking at an unmarried person?
- A) Yes
- B) No
- C) There is not enough information to derive the correct answer.
** Evolution
The human brain is wired to accept the first seemingly fit answer that comes to mind when considering a problem.
It makes sense from an evolutionary point of view: heuristics speed up the process of finding a solution. Speed is important for survival.
** Reasoning and Logic
#+BEGIN_QUOTE
Psychologists concur with philosophers in the irrelevance of logic to everyday reasoning. Decades of work on Wason’s selection task seem to confirm this. — Pascal Engels
#+END_QUOTE
** Thinking, Fast and Slow
Following Daniel Kahneman’s terminology, the brain works in two modes, system 1 and system 2. System 1 is the thinking that is fast, intuitive, and unaware of its workings. System 2 is the slow thinking able to correct system 1’s mistakes. The problem is that we often fail to recognize when we need to switch gear and slow down. 
** So, programming are we?
Question: When we program, do we use system 1 or system 2?
** Well
We use both. When we learn or face a difficult part of the program, we use system 2, but most of the time we’ll try to maximize system 1 and proceed fast to use what we’ve learnt, what we already know.
** Regularity
Learnability of a system (programming language) depends on the regularity it provides. When we learn a language, We develop intuitions around it. We are able to predict that the runtime is going to do y if we write x. 
** How do you infuse regularity to a programming language?
By making it adhere to well-defined rules. 
#+BEGIN_QUOTE
Computation is a process following a well-defined model expressed as, for example, an algorithm, or a protocol. — Wikipedia
#+END_QUOTE
Models of computation are extremely useful to inventors/designers of high-level programming languages.
#+BEGIN_QUOTE
Civilization advances by extending the number of important operations which we can perform without thinking about them" — Alfred North Whitehead
#+END_QUOTE
** Models of computation, some examples
Turing Machines, Cellular Automata, Finite State Machines, Stack Machines, Graph Automata, Lambda Calculus, Fractran, Tiling Systems, Chemical Reaction Systems, Hopfield Networks, Boltzmann Machines, Neural Networks, Circuits, Graphical Models, Boolean Algebra, String Rewriting Systems, Semigroups, Quantum Waves, Diophantine Equations, Tag Systems, The Actor Model, etc.
** Models of computation
- Some models of computations are more succesful than others.
- [[https://github.com/Dobiasd/articles/blob/master/programming_language_learning_curves.md][Learning Curves for several programming languages]]
- Lambda Calculus is at the heart of two of the most highly regarded programming languages: Haskell and Lisp.
** Lambda Calculus
Alonzo Church developed a notation for arbitrary functions. His notation is called λ-calculus (“lambda calculus”). Church introduced his formalism to give a functional foundation for Mathematics but in the end mathematicians preferred (axiomatic) set theory. The λ-calculus was re-discovered as a versatile tool in Computer Science by people like McCarthy, Strachey, Landin, and Scott in the 1960s.
** What did McCarthy discover?
If you try to answer the question, what is the smallest number of operators you need in order to write an interpreter for a language in itself, Lisp is what you get. In other words, Lisp is not something John McCarthy invented, so much as something he discovered.
** Seven operators
If you have seven primitive operators (quote, atom, eq, car, cdr, cons, and cond) then you can define another function, eval, that acts as a Lisp interpreter.
[[https://leanpub.com/readevalprintlove002][A primordial Lisp described in detail.]]
** S-expressions
#+BEGIN_SRC clojure
(a 1 2)
#+END_SRC  
With S-expressions, code and data share the same representation.
** Lisp takes off
LISP became a common language for artificial intelligence (AI) programming, partly owing to the confluence of LISP and AI work at MIT and partly because AI programs capable of "learning" could be written in LISP as self-modifying programs. Since then, it has expanded in a family of dialects, regularly reincarnating in new shape and form but always retaining the same core semantics.
** The importance of Lisp in the industry
Contributions to programming as we know it today. A long list of ideas that originated with Lispers:

- garbage collection
- tree data structures
- if-then-else structure
- dynamic typing
- homoiconicity
- metaprogramming
- self-hosting compilers
- interactive environment

** Clojure is a Lisp
Clojure is pronounced exactly like closure, where the s/j has the zh sound as in azure, pleasure etc. The name was chosen to be unique. I wanted to involve c (c#), l (lisp) and j (java). Once I came up with Clojure, given the pun on closure, the available domains and vast emptiness of the googlespace, it was an easy decision. — Rich Hickey
** Closure 
#+BEGIN_SRC javascript
(function() {
    var x = 0;
    return function() {
        return x;
    }
})();
#+END_SRC
#+BEGIN_QUOTE
Sometimes it's called a closure, other times a saved lexical environment. Or, as some of us like to say, let over lambda. — Let Over Lambda, Doug Hoyte
#+END_QUOTE
#+BEGIN_SRC lisp
(let ((x 0))
    (lambda () x))
#+END_SRC
** Closures are fundamental
Closures are the building blocks of lisp. Closures achieve and provide encapsulation of data and functionality in a single, logical unit.
#+BEGIN_QUOTE
Because of this, lisp programmers often don't think in terms of classes and objects. Once assignable value cells and good old lambda expressions are available, object systems are, at best, occasionally useful abstractions and, at worst, special-case and redundant. — Doug Hoyte, Let Over Lambda, Closure Oriented Programming
#+END_QUOTE
** Closures and OO
#+BEGIN_QUOTE
It's possible, for instance, to implement almost all of the design patterns in the Gang of Four book in terms of Lisp macros. Rather than implementing the pattern each time you use it, you just invoke the correct macro and get it for free. — David Chisnall
#+END_QUOTE
** Functional vs OO
#+BEGIN_QUOTE
Whereas an object-oriented mindset will foster the approach of defining an application domain as a set of nouns (classes), the functional mind will see the solution as the composition or verbs (functions). Though both programmers may in all likelihood generate equivalent results, the functional solution will be more succinct, understandable, and reusable. — Michael Fogus, The Joy Clojure
#+END_QUOTE
** Clojure's motivation
Clojure was born out of frustration provoked in large part by the complexities of concurrent programming, complicated by the weaknesses of object-oriented programming in facilitating it. 
** Simple made easy
[[http://www.infoq.com/presentations/Simple-Made-Easy][Infoq video]]
** Enlightenment
#+BEGIN_QUOTE
Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot." — Eric Raymond
#+END_QUOTE
#+BEGIN_QUOTE
90% of what you learn while studying your first Lisp will carry over to your next.
#+END_QUOTE
* Part II: Data oriented programming
** Syntactic abstraction
The argument making the case for Lisp languages is that of extensibility. No special power to the language designers over its users.
** Homoiconicity
Traditionally, the most defining feature of Lisp. This is a property of homoiconic languages. 
** Clojure’s characteristics
In Clojure: Data -> Functions -> Macros.
** Embrace the data
- Persistent data structure
- Immutability
- Reader syntax for maps, vectors, and sets
- Concurrency primitives to work with data on multiple cores
** Stories
With all the potential of a modern Lisp, a perfect storm is brewing for a wave of innovation.
Clojure has strong stories for: Big data, interactive art (games, music, visuals), web development. 
** Web development
Rethink browser client development: Clojurescript, core.async and Om.
** A DOM of Doom
#+BEGIN_QUOTE
The browser is a vast source of incompatibility, pain and misery. — Douglas Crockford
#+END_QUOTE
[[https://www.youtube.com/watch?v%3DY2Y0U-2qJMs][An Inconvenient API - The Theory of the DOM]] by Douglas Crockford
#+BEGIN_QUOTE
Basically, bugs don’t get fixed in the web. — Douglas Crockford
#+END_QUOTE
* Part III: Clojurescript, core.async and Om
#+BEGIN_QUOTE
“There is no such thing as philosophy-free science; there is only science whose philosophical baggage is taken on board without examination.
—Daniel Dennett, Darwin's Dangerous Idea, 1995”
#+END_QUOTE
